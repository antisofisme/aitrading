"""
Adaptive Strategy Engine - Core adaptive strategy framework
Intelligent strategy adaptation based on market conditions and ML predictions
"""

import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple, Union
from enum import Enum
from dataclasses import dataclass, field
import json

# Service-specific infrastructure
from ....shared.infrastructure.core.logger_core import CoreLogger
from ....shared.infrastructure.core.config_core import CoreConfig
from ....shared.infrastructure.core.error_core import CoreErrorHandler
from ....shared.infrastructure.core.performance_core import CorePerformance
from ....shared.infrastructure.core.cache_core import CoreCache
from ....shared.infrastructure.core.metrics_core import track_counter, track_timer


class StrategyType(Enum):
    """Strategy types for different market conditions"""
    TREND_FOLLOWING = "trend_following"
    MEAN_REVERSION = "mean_reversion"
    BREAKOUT = "breakout"
    MOMENTUM = "momentum"
    COUNTER_TREND = "counter_trend"
    HYBRID = "hybrid"
    ML_DRIVEN = "ml_driven"
    ADAPTIVE = "adaptive"


class StrategyState(Enum):
    """Strategy execution states"""
    ACTIVE = "active"
    PAUSED = "paused"
    STOPPED = "stopped"
    LEARNING = "learning"
    OPTIMIZING = "optimizing"
    FAILED = "failed"


@dataclass
class StrategyConfig:
    """Configuration for strategy parameters"""
    name: str
    strategy_type: StrategyType
    enabled: bool = True
    max_risk_per_trade: float = 0.02
    max_daily_risk: float = 0.10
    min_confidence_threshold: float = 0.70
    lookback_periods: int = 20
    adaptation_frequency: int = 100  # trades
    ml_model_weights: Dict[str, float] = field(default_factory=dict)
    timeframe_weights: Dict[str, float] = field(default_factory=dict)
    risk_multiplier: float = 1.0
    performance_threshold: float = 0.60
    auto_adapt: bool = True
    custom_parameters: Dict[str, Any] = field(default_factory=dict)


@dataclass 
class MarketCondition:
    """Market condition analysis result"""
    volatility: float
    trend_strength: float
    trend_direction: int  # -1, 0, 1
    momentum: float
    volume_profile: float
    correlation_strength: float
    regime: str  # bull, bear, sideways, volatile
    confidence: float
    timestamp: datetime = field(default_factory=datetime.now)


@dataclass
class StrategySignal:
    """Trading signal generated by strategy"""
    strategy_name: str
    signal_type: str  # buy, sell, hold
    confidence: float
    strength: float
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    position_size: Optional[float] = None
    rationale: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)


class AdaptiveStrategyEngine:
    """
    Core adaptive strategy framework that intelligently adapts trading strategies
    based on market conditions, ML predictions, and performance feedback.
    
    Features:
    - Dynamic strategy selection based on market regime
    - ML-driven strategy optimization
    - Real-time performance monitoring and adaptation
    - Multi-timeframe strategy coordination
    - Risk-aware strategy execution
    """

    def __init__(self, service_name: str = "ai-orchestration"):
        """Initialize the adaptive strategy engine"""
        self.service_name = service_name
        self.logger = CoreLogger(service_name, "adaptive_strategy_engine")
        self.config = CoreConfig(service_name)
        self.error_handler = CoreErrorHandler(service_name)
        self.performance = CorePerformance(service_name)
        self.cache = CoreCache(service_name, max_size=10000, ttl=3600)
        
        # Strategy management
        self.strategies: Dict[str, StrategyConfig] = {}
        self.strategy_states: Dict[str, StrategyState] = {}
        self.strategy_performance: Dict[str, Dict[str, float]] = {}
        self.market_conditions: Optional[MarketCondition] = None
        
        # Adaptation parameters
        self.adaptation_history: List[Dict[str, Any]] = []
        self.learning_buffer: List[Dict[str, Any]] = []
        self.performance_window = 100  # trades
        
        # ML integration points
        self.ml_models: Dict[str, Any] = {}
        self.prediction_cache: Dict[str, Any] = {}
        
        self.logger.info("Adaptive Strategy Engine initialized", {
            "service": service_name,
            "strategies_loaded": len(self.strategies),
            "cache_enabled": True
        })

    async def initialize(self) -> bool:
        """Initialize the strategy engine with configuration"""
        try:
            with self.performance.track_operation("strategy_engine_init"):
                # Load strategy configurations
                await self._load_strategy_configs()
                
                # Initialize ML model connections
                await self._initialize_ml_models()
                
                # Setup performance tracking
                await self._setup_performance_tracking()
                
                # Load historical adaptation data
                await self._load_adaptation_history()
                
                self.logger.info("Strategy engine initialization completed", {
                    "strategies_count": len(self.strategies),
                    "ml_models_loaded": len(self.ml_models)
                })
                
                return True
                
        except Exception as e:
            error_context = {
                "operation": "strategy_engine_init",
                "service": self.service_name
            }
            await self.error_handler.handle_error(e, error_context)
            return False

    async def register_strategy(self, config: StrategyConfig) -> bool:
        """Register a new trading strategy"""
        try:
            with self.performance.track_operation("register_strategy"):
                
                # Validate strategy configuration
                if not await self._validate_strategy_config(config):
                    raise ValueError(f"Invalid strategy configuration for {config.name}")
                
                # Register strategy
                self.strategies[config.name] = config
                self.strategy_states[config.name] = StrategyState.ACTIVE if config.enabled else StrategyState.PAUSED
                self.strategy_performance[config.name] = {
                    "total_trades": 0,
                    "winning_trades": 0,
                    "total_pnl": 0.0,
                    "max_drawdown": 0.0,
                    "sharpe_ratio": 0.0,
                    "confidence": 0.0
                }
                
                self.logger.info("Strategy registered successfully", {
                    "strategy_name": config.name,
                    "strategy_type": config.strategy_type.value,
                    "state": self.strategy_states[config.name].value
                })
                
                track_counter("strategy_registered", 1, {"strategy_type": config.strategy_type.value})
                return True
                
        except Exception as e:
            error_context = {
                "operation": "register_strategy",
                "strategy_name": config.name,
                "strategy_type": config.strategy_type.value
            }
            await self.error_handler.handle_error(e, error_context)
            return False

    async def analyze_market_conditions(self, market_data: Dict[str, Any]) -> MarketCondition:
        """Analyze current market conditions for strategy adaptation"""
        try:
            with self.performance.track_operation("analyze_market_conditions"):
                
                # Check cache first
                cache_key = f"market_conditions_{hash(str(market_data))}"
                cached_condition = await self.cache.get(cache_key)
                if cached_condition:
                    return MarketCondition(**cached_condition)
                
                # Calculate market metrics
                volatility = await self._calculate_volatility(market_data)
                trend_strength = await self._calculate_trend_strength(market_data)
                trend_direction = await self._calculate_trend_direction(market_data)
                momentum = await self._calculate_momentum(market_data)
                volume_profile = await self._calculate_volume_profile(market_data)
                correlation_strength = await self._calculate_correlation(market_data)
                
                # Determine market regime
                regime = await self._determine_market_regime(
                    volatility, trend_strength, momentum, volume_profile
                )
                
                # Calculate overall confidence
                confidence = await self._calculate_market_confidence(
                    volatility, trend_strength, momentum, correlation_strength
                )
                
                condition = MarketCondition(
                    volatility=volatility,
                    trend_strength=trend_strength,
                    trend_direction=trend_direction,
                    momentum=momentum,
                    volume_profile=volume_profile,
                    correlation_strength=correlation_strength,
                    regime=regime,
                    confidence=confidence
                )
                
                # Cache the result
                await self.cache.set(cache_key, condition.__dict__, ttl=300)
                
                self.market_conditions = condition
                self.logger.info("Market conditions analyzed", {
                    "regime": regime,
                    "volatility": volatility,
                    "trend_strength": trend_strength,
                    "confidence": confidence
                })
                
                return condition
                
        except Exception as e:
            error_context = {
                "operation": "analyze_market_conditions",
                "data_keys": list(market_data.keys()) if market_data else []
            }
            await self.error_handler.handle_error(e, error_context)
            raise

    async def generate_strategy_signals(self, market_data: Dict[str, Any]) -> List[StrategySignal]:
        """Generate trading signals from all active strategies"""
        try:
            with self.performance.track_operation("generate_strategy_signals"):
                
                signals = []
                
                # Analyze current market conditions
                market_condition = await self.analyze_market_conditions(market_data)
                
                # Generate signals from each active strategy
                for strategy_name, config in self.strategies.items():
                    if self.strategy_states[strategy_name] != StrategyState.ACTIVE:
                        continue
                    
                    try:
                        signal = await self._generate_strategy_signal(
                            config, market_data, market_condition
                        )
                        
                        if signal and signal.confidence >= config.min_confidence_threshold:
                            signals.append(signal)
                            
                    except Exception as e:
                        self.logger.warning("Strategy signal generation failed", {
                            "strategy_name": strategy_name,
                            "error": str(e)
                        })
                        continue
                
                # Apply ML-based signal enhancement
                enhanced_signals = await self._enhance_signals_with_ml(signals, market_data)
                
                # Rank and filter signals
                final_signals = await self._rank_and_filter_signals(enhanced_signals)
                
                self.logger.info("Strategy signals generated", {
                    "total_strategies": len(self.strategies),
                    "active_strategies": len([s for s in self.strategy_states.values() 
                                           if s == StrategyState.ACTIVE]),
                    "signals_generated": len(final_signals)
                })
                
                track_counter("signals_generated", len(final_signals))
                return final_signals
                
        except Exception as e:
            error_context = {
                "operation": "generate_strategy_signals",
                "active_strategies": len([s for s in self.strategy_states.values() 
                                       if s == StrategyState.ACTIVE])
            }
            await self.error_handler.handle_error(e, error_context)
            return []

    async def adapt_strategies(self, performance_feedback: Dict[str, Any]) -> bool:
        """Adapt strategy parameters based on performance feedback"""
        try:
            with self.performance.track_operation("adapt_strategies"):
                
                adaptations_made = 0
                
                for strategy_name, config in self.strategies.items():
                    if not config.auto_adapt:
                        continue
                    
                    # Get strategy performance metrics
                    strategy_perf = self.strategy_performance.get(strategy_name, {})
                    
                    # Determine if adaptation is needed
                    needs_adaptation = await self._should_adapt_strategy(
                        strategy_name, strategy_perf, performance_feedback
                    )
                    
                    if needs_adaptation:
                        # Perform strategy adaptation
                        adapted = await self._adapt_strategy_parameters(
                            strategy_name, config, strategy_perf, performance_feedback
                        )
                        
                        if adapted:
                            adaptations_made += 1
                            
                            # Log adaptation
                            adaptation_record = {
                                "strategy_name": strategy_name,
                                "timestamp": datetime.now().isoformat(),
                                "performance_before": strategy_perf.copy(),
                                "trigger": "performance_feedback",
                                "market_conditions": self.market_conditions.__dict__ if self.market_conditions else None
                            }
                            self.adaptation_history.append(adaptation_record)
                
                self.logger.info("Strategy adaptation completed", {
                    "strategies_evaluated": len(self.strategies),
                    "adaptations_made": adaptations_made,
                    "total_adaptations": len(self.adaptation_history)
                })
                
                track_counter("strategy_adaptations", adaptations_made)
                return adaptations_made > 0
                
        except Exception as e:
            error_context = {
                "operation": "adapt_strategies",
                "strategies_count": len(self.strategies)
            }
            await self.error_handler.handle_error(e, error_context)
            return False

    async def update_strategy_performance(self, strategy_name: str, trade_result: Dict[str, Any]) -> bool:
        """Update strategy performance metrics with new trade result"""
        try:
            if strategy_name not in self.strategy_performance:
                self.strategy_performance[strategy_name] = {
                    "total_trades": 0,
                    "winning_trades": 0,
                    "total_pnl": 0.0,
                    "max_drawdown": 0.0,
                    "sharpe_ratio": 0.0,
                    "confidence": 0.0
                }
            
            perf = self.strategy_performance[strategy_name]
            
            # Update basic metrics
            perf["total_trades"] += 1
            perf["total_pnl"] += trade_result.get("pnl", 0.0)
            
            if trade_result.get("pnl", 0.0) > 0:
                perf["winning_trades"] += 1
            
            # Calculate win rate
            win_rate = perf["winning_trades"] / perf["total_trades"] if perf["total_trades"] > 0 else 0
            
            # Update drawdown
            if trade_result.get("pnl", 0.0) < 0:
                current_drawdown = abs(trade_result.get("pnl", 0.0))
                perf["max_drawdown"] = max(perf["max_drawdown"], current_drawdown)
            
            # Calculate confidence based on recent performance
            perf["confidence"] = await self._calculate_strategy_confidence(strategy_name, perf)
            
            # Store in learning buffer for adaptation
            self.learning_buffer.append({
                "strategy_name": strategy_name,
                "trade_result": trade_result,
                "performance_snapshot": perf.copy(),
                "market_conditions": self.market_conditions.__dict__ if self.market_conditions else None,
                "timestamp": datetime.now().isoformat()
            })
            
            # Trim learning buffer
            if len(self.learning_buffer) > self.performance_window * 2:
                self.learning_buffer = self.learning_buffer[-self.performance_window:]
            
            self.logger.debug("Strategy performance updated", {
                "strategy_name": strategy_name,
                "total_trades": perf["total_trades"],
                "win_rate": win_rate,
                "total_pnl": perf["total_pnl"],
                "confidence": perf["confidence"]
            })
            
            return True
            
        except Exception as e:
            error_context = {
                "operation": "update_strategy_performance",
                "strategy_name": strategy_name,
                "trade_result": trade_result
            }
            await self.error_handler.handle_error(e, error_context)
            return False

    async def get_strategy_status(self) -> Dict[str, Any]:
        """Get comprehensive status of all strategies"""
        try:
            status = {
                "total_strategies": len(self.strategies),
                "active_strategies": len([s for s in self.strategy_states.values() 
                                       if s == StrategyState.ACTIVE]),
                "strategy_details": {},
                "market_conditions": self.market_conditions.__dict__ if self.market_conditions else None,
                "adaptation_count": len(self.adaptation_history),
                "last_adaptation": self.adaptation_history[-1] if self.adaptation_history else None,
                "timestamp": datetime.now().isoformat()
            }
            
            for strategy_name, config in self.strategies.items():
                status["strategy_details"][strategy_name] = {
                    "type": config.strategy_type.value,
                    "state": self.strategy_states[strategy_name].value,
                    "performance": self.strategy_performance.get(strategy_name, {}),
                    "enabled": config.enabled,
                    "auto_adapt": config.auto_adapt
                }
            
            return status
            
        except Exception as e:
            error_context = {"operation": "get_strategy_status"}
            await self.error_handler.handle_error(e, error_context)
            return {"error": "Failed to get strategy status"}

    # Private helper methods
    
    async def _load_strategy_configs(self) -> None:
        """Load strategy configurations from config system"""
        try:
            config_data = await self.config.get_nested_config("strategies", {})
            
            for strategy_name, strategy_config in config_data.items():
                config = StrategyConfig(
                    name=strategy_name,
                    strategy_type=StrategyType(strategy_config.get("type", "adaptive")),
                    enabled=strategy_config.get("enabled", True),
                    max_risk_per_trade=strategy_config.get("max_risk_per_trade", 0.02),
                    max_daily_risk=strategy_config.get("max_daily_risk", 0.10),
                    min_confidence_threshold=strategy_config.get("min_confidence_threshold", 0.70),
                    lookback_periods=strategy_config.get("lookback_periods", 20),
                    adaptation_frequency=strategy_config.get("adaptation_frequency", 100),
                    ml_model_weights=strategy_config.get("ml_model_weights", {}),
                    timeframe_weights=strategy_config.get("timeframe_weights", {}),
                    risk_multiplier=strategy_config.get("risk_multiplier", 1.0),
                    performance_threshold=strategy_config.get("performance_threshold", 0.60),
                    auto_adapt=strategy_config.get("auto_adapt", True),
                    custom_parameters=strategy_config.get("custom_parameters", {})
                )
                
                await self.register_strategy(config)
                
        except Exception as e:
            self.logger.warning("Failed to load strategy configs", {"error": str(e)})

    async def _initialize_ml_models(self) -> None:
        """Initialize ML model connections"""
        try:
            # This would integrate with ML processing service
            # For now, we'll set up placeholders
            self.ml_models = {
                "trend_predictor": {"status": "connected", "confidence": 0.85},
                "volatility_forecaster": {"status": "connected", "confidence": 0.78},
                "sentiment_analyzer": {"status": "connected", "confidence": 0.82},
                "pattern_recognizer": {"status": "connected", "confidence": 0.88}
            }
            
        except Exception as e:
            self.logger.warning("Failed to initialize ML models", {"error": str(e)})

    async def _setup_performance_tracking(self) -> None:
        """Setup performance tracking infrastructure"""
        try:
            # Initialize performance tracking for each strategy type
            for strategy_type in StrategyType:
                track_counter(f"strategy_{strategy_type.value}_signals", 0)
                track_counter(f"strategy_{strategy_type.value}_trades", 0)
                
        except Exception as e:
            self.logger.warning("Failed to setup performance tracking", {"error": str(e)})

    async def _load_adaptation_history(self) -> None:
        """Load historical adaptation data"""
        try:
            # Load from cache or persistent storage
            cached_history = await self.cache.get("adaptation_history")
            if cached_history:
                self.adaptation_history = json.loads(cached_history)
                
        except Exception as e:
            self.logger.warning("Failed to load adaptation history", {"error": str(e)})

    async def _validate_strategy_config(self, config: StrategyConfig) -> bool:
        """Validate strategy configuration"""
        try:
            # Basic validation
            if not config.name or not config.strategy_type:
                return False
            
            if config.max_risk_per_trade <= 0 or config.max_risk_per_trade > 1:
                return False
            
            if config.max_daily_risk <= 0 or config.max_daily_risk > 1:
                return False
            
            if config.min_confidence_threshold < 0 or config.min_confidence_threshold > 1:
                return False
            
            return True
            
        except Exception:
            return False

    async def _calculate_volatility(self, market_data: Dict[str, Any]) -> float:
        """Calculate market volatility"""
        try:
            # Simple volatility calculation based on price data
            prices = market_data.get("prices", [])
            if len(prices) < 2:
                return 0.0
            
            returns = [(prices[i] - prices[i-1]) / prices[i-1] for i in range(1, len(prices))]
            if not returns:
                return 0.0
            
            mean_return = sum(returns) / len(returns)
            variance = sum((r - mean_return) ** 2 for r in returns) / len(returns)
            volatility = variance ** 0.5
            
            return min(volatility, 1.0)  # Cap at 1.0
            
        except Exception:
            return 0.0

    async def _calculate_trend_strength(self, market_data: Dict[str, Any]) -> float:
        """Calculate trend strength"""
        try:
            prices = market_data.get("prices", [])
            if len(prices) < 10:
                return 0.0
            
            # Simple trend strength using linear regression-like approach
            n = len(prices)
            x_sum = sum(range(n))
            y_sum = sum(prices)
            xy_sum = sum(i * prices[i] for i in range(n))
            x2_sum = sum(i * i for i in range(n))
            
            slope = (n * xy_sum - x_sum * y_sum) / (n * x2_sum - x_sum * x_sum)
            
            # Normalize slope to 0-1 range
            max_slope = max(prices) / len(prices)
            trend_strength = min(abs(slope) / max_slope, 1.0) if max_slope > 0 else 0.0
            
            return trend_strength
            
        except Exception:
            return 0.0

    async def _calculate_trend_direction(self, market_data: Dict[str, Any]) -> int:
        """Calculate trend direction (-1, 0, 1)"""
        try:
            prices = market_data.get("prices", [])
            if len(prices) < 2:
                return 0
            
            recent_change = prices[-1] - prices[0]
            
            if recent_change > 0:
                return 1
            elif recent_change < 0:
                return -1
            else:
                return 0
                
        except Exception:
            return 0

    async def _calculate_momentum(self, market_data: Dict[str, Any]) -> float:
        """Calculate momentum"""
        try:
            prices = market_data.get("prices", [])
            volumes = market_data.get("volumes", [])
            
            if len(prices) < 5:
                return 0.0
            
            # Calculate rate of change
            roc = (prices[-1] - prices[-5]) / prices[-5] if prices[-5] != 0 else 0
            
            # Factor in volume if available
            volume_factor = 1.0
            if volumes and len(volumes) >= 5:
                avg_volume = sum(volumes[-5:]) / 5
                recent_volume = sum(volumes[-2:]) / 2
                volume_factor = min(recent_volume / avg_volume, 2.0) if avg_volume > 0 else 1.0
            
            momentum = abs(roc) * volume_factor
            return min(momentum, 1.0)
            
        except Exception:
            return 0.0

    async def _calculate_volume_profile(self, market_data: Dict[str, Any]) -> float:
        """Calculate volume profile"""
        try:
            volumes = market_data.get("volumes", [])
            if len(volumes) < 10:
                return 0.5  # Neutral
            
            recent_avg = sum(volumes[-5:]) / 5
            historical_avg = sum(volumes[-20:]) / 20
            
            profile = recent_avg / historical_avg if historical_avg > 0 else 1.0
            return min(max(profile, 0.0), 2.0) / 2.0  # Normalize to 0-1
            
        except Exception:
            return 0.5

    async def _calculate_correlation(self, market_data: Dict[str, Any]) -> float:
        """Calculate correlation strength"""
        try:
            # Simple correlation proxy based on price consistency
            prices = market_data.get("prices", [])
            if len(prices) < 10:
                return 0.5
            
            # Calculate directional consistency
            directions = [1 if prices[i] > prices[i-1] else -1 for i in range(1, len(prices))]
            consistency = abs(sum(directions)) / len(directions) if directions else 0
            
            return consistency
            
        except Exception:
            return 0.5

    async def _determine_market_regime(self, volatility: float, trend_strength: float, 
                                     momentum: float, volume_profile: float) -> str:
        """Determine market regime based on metrics"""
        try:
            if volatility > 0.7:
                return "volatile"
            elif trend_strength > 0.6 and momentum > 0.5:
                return "bull" if volume_profile > 0.6 else "bear"
            elif trend_strength < 0.3 and momentum < 0.3:
                return "sideways"
            else:
                return "transitional"
                
        except Exception:
            return "unknown"

    async def _calculate_market_confidence(self, volatility: float, trend_strength: float,
                                         momentum: float, correlation_strength: float) -> float:
        """Calculate overall market confidence"""
        try:
            # Weighted confidence calculation
            confidence = (
                (1 - volatility) * 0.3 +  # Lower volatility = higher confidence
                trend_strength * 0.3 +    # Stronger trend = higher confidence
                momentum * 0.2 +          # Higher momentum = higher confidence
                correlation_strength * 0.2  # Higher correlation = higher confidence
            )
            
            return min(max(confidence, 0.0), 1.0)
            
        except Exception:
            return 0.5

    async def _generate_strategy_signal(self, config: StrategyConfig, market_data: Dict[str, Any],
                                      market_condition: MarketCondition) -> Optional[StrategySignal]:
        """Generate signal for specific strategy"""
        try:
            # Strategy-specific signal generation logic
            signal_strength = 0.0
            signal_type = "hold"
            confidence = 0.0
            
            if config.strategy_type == StrategyType.TREND_FOLLOWING:
                if market_condition.trend_strength > 0.6:
                    signal_type = "buy" if market_condition.trend_direction > 0 else "sell"
                    signal_strength = market_condition.trend_strength
                    confidence = market_condition.trend_strength * market_condition.confidence
                    
            elif config.strategy_type == StrategyType.MEAN_REVERSION:
                if market_condition.volatility > 0.5 and market_condition.trend_strength < 0.4:
                    signal_type = "buy" if market_condition.trend_direction < 0 else "sell"
                    signal_strength = 1 - market_condition.trend_strength
                    confidence = (1 - market_condition.trend_strength) * market_condition.confidence
                    
            elif config.strategy_type == StrategyType.MOMENTUM:
                if market_condition.momentum > 0.6:
                    signal_type = "buy" if market_condition.trend_direction > 0 else "sell"
                    signal_strength = market_condition.momentum
                    confidence = market_condition.momentum * market_condition.confidence
                    
            # Apply ML enhancements if available
            if self.ml_models and confidence > 0:
                ml_boost = await self._get_ml_signal_boost(config, market_data)
                confidence *= ml_boost
                signal_strength *= ml_boost
            
            if confidence < config.min_confidence_threshold:
                return None
            
            return StrategySignal(
                strategy_name=config.name,
                signal_type=signal_type,
                confidence=confidence,
                strength=signal_strength,
                rationale=f"{config.strategy_type.value} signal based on market regime: {market_condition.regime}",
                metadata={
                    "strategy_type": config.strategy_type.value,
                    "market_regime": market_condition.regime,
                    "volatility": market_condition.volatility,
                    "trend_strength": market_condition.trend_strength,
                    "momentum": market_condition.momentum
                }
            )
            
        except Exception as e:
            self.logger.warning("Failed to generate strategy signal", {
                "strategy_name": config.name,
                "error": str(e)
            })
            return None

    async def _enhance_signals_with_ml(self, signals: List[StrategySignal], 
                                     market_data: Dict[str, Any]) -> List[StrategySignal]:
        """Enhance signals using ML predictions"""
        try:
            enhanced_signals = []
            
            for signal in signals:
                # Apply ML-based confidence adjustment
                ml_confidence = await self._get_ml_confidence(signal, market_data)
                
                # Create enhanced signal
                enhanced_signal = StrategySignal(
                    strategy_name=signal.strategy_name,
                    signal_type=signal.signal_type,
                    confidence=signal.confidence * ml_confidence,
                    strength=signal.strength * ml_confidence,
                    entry_price=signal.entry_price,
                    stop_loss=signal.stop_loss,
                    take_profit=signal.take_profit,
                    position_size=signal.position_size,
                    rationale=f"{signal.rationale} (ML enhanced: {ml_confidence:.2f})",
                    metadata={**signal.metadata, "ml_enhancement": ml_confidence},
                    timestamp=signal.timestamp
                )
                
                enhanced_signals.append(enhanced_signal)
            
            return enhanced_signals
            
        except Exception as e:
            self.logger.warning("Failed to enhance signals with ML", {"error": str(e)})
            return signals

    async def _rank_and_filter_signals(self, signals: List[StrategySignal]) -> List[StrategySignal]:
        """Rank and filter signals based on quality"""
        try:
            # Sort by confidence * strength
            ranked_signals = sorted(
                signals,
                key=lambda s: s.confidence * s.strength,
                reverse=True
            )
            
            # Apply additional filtering logic
            filtered_signals = []
            for signal in ranked_signals:
                # Skip if confidence too low
                if signal.confidence < 0.5:
                    continue
                
                # Skip if conflicting with higher-ranked signals
                if await self._has_signal_conflict(signal, filtered_signals):
                    continue
                
                filtered_signals.append(signal)
                
                # Limit number of signals
                if len(filtered_signals) >= 5:
                    break
            
            return filtered_signals
            
        except Exception as e:
            self.logger.warning("Failed to rank and filter signals", {"error": str(e)})
            return signals

    async def _should_adapt_strategy(self, strategy_name: str, strategy_perf: Dict[str, Any],
                                   performance_feedback: Dict[str, Any]) -> bool:
        """Determine if strategy needs adaptation"""
        try:
            # Check if enough trades have occurred
            total_trades = strategy_perf.get("total_trades", 0)
            if total_trades < 10:
                return False
            
            # Check performance threshold
            confidence = strategy_perf.get("confidence", 0.0)
            config = self.strategies.get(strategy_name)
            if not config:
                return False
            
            if confidence < config.performance_threshold:
                return True
            
            # Check if adaptation frequency reached
            if total_trades % config.adaptation_frequency == 0:
                return True
            
            return False
            
        except Exception:
            return False

    async def _adapt_strategy_parameters(self, strategy_name: str, config: StrategyConfig,
                                       strategy_perf: Dict[str, Any], 
                                       performance_feedback: Dict[str, Any]) -> bool:
        """Adapt strategy parameters based on performance"""
        try:
            # Simple adaptation logic - adjust risk and confidence thresholds
            confidence = strategy_perf.get("confidence", 0.0)
            
            if confidence < 0.4:
                # Reduce risk and increase confidence threshold
                config.max_risk_per_trade *= 0.8
                config.min_confidence_threshold = min(config.min_confidence_threshold * 1.1, 0.9)
            elif confidence > 0.8:
                # Increase risk and reduce confidence threshold
                config.max_risk_per_trade = min(config.max_risk_per_trade * 1.1, 0.05)
                config.min_confidence_threshold = max(config.min_confidence_threshold * 0.95, 0.5)
            
            # Update ML model weights based on performance
            if self.ml_models:
                for model_name in self.ml_models:
                    current_weight = config.ml_model_weights.get(model_name, 1.0)
                    if confidence > 0.7:
                        config.ml_model_weights[model_name] = min(current_weight * 1.05, 2.0)
                    else:
                        config.ml_model_weights[model_name] = max(current_weight * 0.95, 0.5)
            
            self.logger.info("Strategy parameters adapted", {
                "strategy_name": strategy_name,
                "new_risk_per_trade": config.max_risk_per_trade,
                "new_confidence_threshold": config.min_confidence_threshold,
                "performance_confidence": confidence
            })
            
            return True
            
        except Exception as e:
            self.logger.warning("Failed to adapt strategy parameters", {
                "strategy_name": strategy_name,
                "error": str(e)
            })
            return False

    async def _calculate_strategy_confidence(self, strategy_name: str, perf: Dict[str, Any]) -> float:
        """Calculate strategy confidence based on performance"""
        try:
            total_trades = perf.get("total_trades", 0)
            if total_trades == 0:
                return 0.0
            
            win_rate = perf.get("winning_trades", 0) / total_trades
            total_pnl = perf.get("total_pnl", 0.0)
            max_drawdown = perf.get("max_drawdown", 0.0)
            
            # Simple confidence calculation
            confidence = (
                win_rate * 0.4 +
                (1.0 if total_pnl > 0 else 0.0) * 0.3 +
                (1.0 - min(max_drawdown / abs(total_pnl), 1.0) if total_pnl != 0 else 0.0) * 0.3
            )
            
            return min(max(confidence, 0.0), 1.0)
            
        except Exception:
            return 0.5

    async def _get_ml_signal_boost(self, config: StrategyConfig, market_data: Dict[str, Any]) -> float:
        """Get ML-based signal boost factor"""
        try:
            # Placeholder for ML integration
            # This would call ML processing service
            base_boost = 1.0
            
            for model_name, model_info in self.ml_models.items():
                weight = config.ml_model_weights.get(model_name, 1.0)
                model_confidence = model_info.get("confidence", 0.5)
                base_boost *= (1.0 + (model_confidence - 0.5) * weight * 0.2)
            
            return min(max(base_boost, 0.5), 2.0)
            
        except Exception:
            return 1.0

    async def _get_ml_confidence(self, signal: StrategySignal, market_data: Dict[str, Any]) -> float:
        """Get ML-based confidence adjustment"""
        try:
            # Placeholder for ML confidence calculation
            # This would integrate with ML models
            base_confidence = 1.0
            
            # Simple logic based on market conditions
            if self.market_conditions:
                if self.market_conditions.regime in ["bull", "bear"]:
                    base_confidence *= 1.1
                elif self.market_conditions.regime == "volatile":
                    base_confidence *= 0.9
            
            return min(max(base_confidence, 0.5), 1.5)
            
        except Exception:
            return 1.0

    async def _has_signal_conflict(self, signal: StrategySignal, existing_signals: List[StrategySignal]) -> bool:
        """Check if signal conflicts with existing signals"""
        try:
            for existing in existing_signals:
                # Opposite signals conflict
                if ((signal.signal_type == "buy" and existing.signal_type == "sell") or
                    (signal.signal_type == "sell" and existing.signal_type == "buy")):
                    return True
            
            return False
            
        except Exception:
            return False