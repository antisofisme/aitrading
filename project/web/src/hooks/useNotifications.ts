import { useState, useEffect, useCallback } from 'react';\nimport { Notification, NotificationType, NotificationSeverity } from '@/types';\nimport { apiService } from '@/services/api';\nimport { wsService } from '@/services/websocket';\n\ninterface UseNotificationsReturn {\n  notifications: Notification[];\n  unreadCount: number;\n  isLoading: boolean;\n  error: string | null;\n  markAsRead: (notificationId: string) => Promise<void>;\n  markAllAsRead: () => Promise<void>;\n  addNotification: (notification: Omit<Notification, 'id' | 'createdAt'>) => void;\n  removeNotification: (notificationId: string) => void;\n  clearAll: () => void;\n  refresh: () => Promise<void>;\n}\n\nexport const useNotifications = (): UseNotificationsReturn => {\n  const [notifications, setNotifications] = useState<Notification[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // Calculate unread count\n  const unreadCount = notifications.filter(n => !n.read).length;\n\n  // Fetch notifications from API\n  const fetchNotifications = useCallback(async () => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      const data = await apiService.getNotifications();\n      setNotifications(data);\n    } catch (err: any) {\n      setError(err.message || 'Failed to fetch notifications');\n      console.error('Failed to fetch notifications:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  // Initialize notifications and WebSocket listeners\n  useEffect(() => {\n    fetchNotifications();\n\n    // Listen for real-time notifications\n    const handleNewNotification = (data: any) => {\n      const notification: Notification = {\n        id: data.id || Date.now().toString(),\n        type: data.type || NotificationType.INFO,\n        title: data.title || 'Notification',\n        message: data.message || '',\n        severity: data.severity || NotificationSeverity.LOW,\n        read: false,\n        createdAt: new Date(data.timestamp || Date.now()),\n        actionUrl: data.actionUrl,\n      };\n      \n      setNotifications(prev => [notification, ...prev]);\n      \n      // Show browser notification if permission granted\n      if (Notification.permission === 'granted') {\n        new Notification(notification.title, {\n          body: notification.message,\n          icon: '/favicon.ico',\n          tag: notification.id,\n        });\n      }\n    };\n\n    const handleSystemAlert = (data: any) => {\n      handleNewNotification({\n        ...data,\n        type: NotificationType.SYSTEM_ALERT,\n        severity: NotificationSeverity.HIGH,\n      });\n    };\n\n    const handleTradeAlert = (data: any) => {\n      handleNewNotification({\n        ...data,\n        type: NotificationType.TRADE_ALERT,\n        severity: NotificationSeverity.MEDIUM,\n      });\n    };\n\n    const handleAIPrediction = (data: any) => {\n      handleNewNotification({\n        title: 'AI Signal',\n        message: `${data.direction.toUpperCase()} signal for ${data.symbol} (${Math.round(data.confidence * 100)}% confidence)`,\n        type: NotificationType.AI_SIGNAL,\n        severity: NotificationSeverity.MEDIUM,\n        actionUrl: `/trading?symbol=${data.symbol}`,\n      });\n    };\n\n    // Subscribe to WebSocket events\n    wsService.on('notification', handleNewNotification);\n    wsService.on('system_alert', handleSystemAlert);\n    wsService.on('trade_alert', handleTradeAlert);\n    wsService.on('ai_prediction', handleAIPrediction);\n\n    return () => {\n      wsService.off('notification', handleNewNotification);\n      wsService.off('system_alert', handleSystemAlert);\n      wsService.off('trade_alert', handleTradeAlert);\n      wsService.off('ai_prediction', handleAIPrediction);\n    };\n  }, [fetchNotifications]);\n\n  // Request notification permission on mount\n  useEffect(() => {\n    if ('Notification' in window && Notification.permission === 'default') {\n      Notification.requestPermission();\n    }\n  }, []);\n\n  // Mark notification as read\n  const markAsRead = async (notificationId: string) => {\n    try {\n      await apiService.markNotificationRead(notificationId);\n      setNotifications(prev => \n        prev.map(n => \n          n.id === notificationId ? { ...n, read: true } : n\n        )\n      );\n    } catch (err: any) {\n      console.error('Failed to mark notification as read:', err);\n      setError(err.message || 'Failed to mark notification as read');\n    }\n  };\n\n  // Mark all notifications as read\n  const markAllAsRead = async () => {\n    try {\n      await apiService.markAllNotificationsRead();\n      setNotifications(prev => \n        prev.map(n => ({ ...n, read: true }))\n      );\n    } catch (err: any) {\n      console.error('Failed to mark all notifications as read:', err);\n      setError(err.message || 'Failed to mark all notifications as read');\n    }\n  };\n\n  // Add notification locally (for real-time updates)\n  const addNotification = (notification: Omit<Notification, 'id' | 'createdAt'>) => {\n    const newNotification: Notification = {\n      ...notification,\n      id: Date.now().toString(),\n      createdAt: new Date(),\n    };\n    \n    setNotifications(prev => [newNotification, ...prev]);\n  };\n\n  // Remove notification\n  const removeNotification = (notificationId: string) => {\n    setNotifications(prev => prev.filter(n => n.id !== notificationId));\n  };\n\n  // Clear all notifications\n  const clearAll = () => {\n    setNotifications([]);\n  };\n\n  // Refresh notifications\n  const refresh = fetchNotifications;\n\n  return {\n    notifications,\n    unreadCount,\n    isLoading,\n    error,\n    markAsRead,\n    markAllAsRead,\n    addNotification,\n    removeNotification,\n    clearAll,\n    refresh,\n  };\n};\n\n// Helper function to create notification\nexport const createNotification = (\n  title: string,\n  message: string,\n  type: NotificationType = NotificationType.INFO,\n  severity: NotificationSeverity = NotificationSeverity.LOW,\n  actionUrl?: string\n): Omit<Notification, 'id' | 'createdAt'> => {\n  return {\n    type,\n    title,\n    message,\n    severity,\n    read: false,\n    actionUrl,\n  };\n};\n\n// Helper function to show toast-like notification\nexport const showToastNotification = (title: string, message: string) => {\n  if ('Notification' in window && Notification.permission === 'granted') {\n    new Notification(title, {\n      body: message,\n      icon: '/favicon.ico',\n    });\n  }\n};