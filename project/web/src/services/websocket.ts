import { io, Socket } from 'socket.io-client';\nimport { WSMessage, WSMessageType, MarketData, Position, Order, AIPrediction } from '@/types';\n\n// WebSocket Configuration\nconst WS_URL = process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:8000';\nconst RECONNECT_INTERVAL = parseInt(process.env.NEXT_PUBLIC_WS_RECONNECT_INTERVAL || '5000');\n\ntype EventCallback = (data: any) => void;\n\nclass WebSocketService {\n  private socket: Socket | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 10;\n  private reconnectTimer: NodeJS.Timeout | null = null;\n  private eventCallbacks: Map<string, EventCallback[]> = new Map();\n  private connectionStatus: 'connected' | 'connecting' | 'disconnected' = 'disconnected';\n  private authToken: string | null = null;\n\n  constructor() {\n    this.initializeSocket();\n  }\n\n  private initializeSocket() {\n    if (this.socket) {\n      this.socket.disconnect();\n    }\n\n    this.connectionStatus = 'connecting';\n    \n    this.socket = io(WS_URL, {\n      transports: ['websocket'],\n      upgrade: true,\n      rememberUpgrade: true,\n      timeout: 10000,\n      forceNew: true,\n      auth: {\n        token: this.authToken,\n      },\n    });\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers() {\n    if (!this.socket) return;\n\n    // Connection events\n    this.socket.on('connect', () => {\n      console.log('WebSocket connected');\n      this.connectionStatus = 'connected';\n      this.reconnectAttempts = 0;\n      this.clearReconnectTimer();\n      this.emit('connection', { status: 'connected' });\n    });\n\n    this.socket.on('disconnect', (reason) => {\n      console.log('WebSocket disconnected:', reason);\n      this.connectionStatus = 'disconnected';\n      this.emit('connection', { status: 'disconnected', reason });\n      \n      if (reason === 'io server disconnect') {\n        // Server initiated disconnect, don't reconnect automatically\n        return;\n      }\n      \n      this.handleReconnect();\n    });\n\n    this.socket.on('connect_error', (error) => {\n      console.error('WebSocket connection error:', error);\n      this.connectionStatus = 'disconnected';\n      this.emit('connection', { status: 'error', error: error.message });\n      this.handleReconnect();\n    });\n\n    // Market data events\n    this.socket.on('market_data', (data: MarketData) => {\n      this.emit(WSMessageType.MARKET_DATA, data);\n    });\n\n    this.socket.on('tick', (data: any) => {\n      this.emit('tick', data);\n    });\n\n    // Trading events\n    this.socket.on('position_update', (data: Position) => {\n      this.emit(WSMessageType.POSITION_UPDATE, data);\n    });\n\n    this.socket.on('order_update', (data: Order) => {\n      this.emit(WSMessageType.ORDER_UPDATE, data);\n    });\n\n    // AI events\n    this.socket.on('ai_prediction', (data: AIPrediction) => {\n      this.emit(WSMessageType.AI_PREDICTION, data);\n    });\n\n    // System events\n    this.socket.on('notification', (data: any) => {\n      this.emit(WSMessageType.NOTIFICATION, data);\n    });\n\n    this.socket.on('system_alert', (data: any) => {\n      this.emit('system_alert', data);\n    });\n\n    // Heartbeat\n    this.socket.on('heartbeat', () => {\n      this.emit(WSMessageType.HEARTBEAT, { timestamp: new Date() });\n    });\n\n    // Error handling\n    this.socket.on('error', (error) => {\n      console.error('WebSocket error:', error);\n      this.emit('error', error);\n    });\n  }\n\n  private handleReconnect() {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      this.emit('connection', { status: 'failed', attempts: this.reconnectAttempts });\n      return;\n    }\n\n    this.reconnectAttempts++;\n    const delay = Math.min(RECONNECT_INTERVAL * this.reconnectAttempts, 30000);\n    \n    console.log(`Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts})`);\n    \n    this.reconnectTimer = setTimeout(() => {\n      this.initializeSocket();\n    }, delay);\n  }\n\n  private clearReconnectTimer() {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n\n  // Public methods\n  connect(token?: string) {\n    if (token) {\n      this.authToken = token;\n    }\n    \n    if (this.connectionStatus === 'disconnected') {\n      this.initializeSocket();\n    }\n  }\n\n  disconnect() {\n    this.clearReconnectTimer();\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n    this.connectionStatus = 'disconnected';\n  }\n\n  // Event subscription\n  on(event: string, callback: EventCallback) {\n    if (!this.eventCallbacks.has(event)) {\n      this.eventCallbacks.set(event, []);\n    }\n    this.eventCallbacks.get(event)!.push(callback);\n  }\n\n  off(event: string, callback?: EventCallback) {\n    if (!this.eventCallbacks.has(event)) return;\n    \n    if (callback) {\n      const callbacks = this.eventCallbacks.get(event)!;\n      const index = callbacks.indexOf(callback);\n      if (index > -1) {\n        callbacks.splice(index, 1);\n      }\n    } else {\n      this.eventCallbacks.delete(event);\n    }\n  }\n\n  private emit(event: string, data: any) {\n    const callbacks = this.eventCallbacks.get(event);\n    if (callbacks) {\n      callbacks.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in WebSocket callback:', error);\n        }\n      });\n    }\n  }\n\n  // Send messages\n  send(event: string, data: any) {\n    if (this.socket && this.connectionStatus === 'connected') {\n      this.socket.emit(event, data);\n    } else {\n      console.warn('WebSocket not connected, message not sent:', event, data);\n    }\n  }\n\n  // Subscribe to specific symbols\n  subscribeToSymbol(symbol: string) {\n    this.send('subscribe', { type: 'symbol', symbol });\n  }\n\n  unsubscribeFromSymbol(symbol: string) {\n    this.send('unsubscribe', { type: 'symbol', symbol });\n  }\n\n  // Subscribe to trading updates\n  subscribeToTradingUpdates() {\n    this.send('subscribe', { type: 'trading' });\n  }\n\n  // Subscribe to AI predictions\n  subscribeToAIPredictions(symbols?: string[]) {\n    this.send('subscribe', { type: 'ai_predictions', symbols });\n  }\n\n  // Get connection status\n  getConnectionStatus() {\n    return this.connectionStatus;\n  }\n\n  isConnected() {\n    return this.connectionStatus === 'connected';\n  }\n\n  // Utility methods\n  setAuthToken(token: string) {\n    this.authToken = token;\n    if (this.socket) {\n      this.socket.auth = { token };\n    }\n  }\n\n  clearAuthToken() {\n    this.authToken = null;\n    if (this.socket) {\n      this.socket.auth = {};\n    }\n  }\n}\n\n// Export singleton instance\nexport const wsService = new WebSocketService();\nexport default wsService;\n\n// Utility hooks for React components\nexport const useWebSocket = () => {\n  return {\n    connect: wsService.connect.bind(wsService),\n    disconnect: wsService.disconnect.bind(wsService),\n    on: wsService.on.bind(wsService),\n    off: wsService.off.bind(wsService),\n    send: wsService.send.bind(wsService),\n    isConnected: wsService.isConnected.bind(wsService),\n    getConnectionStatus: wsService.getConnectionStatus.bind(wsService),\n    subscribeToSymbol: wsService.subscribeToSymbol.bind(wsService),\n    unsubscribeFromSymbol: wsService.unsubscribeFromSymbol.bind(wsService),\n    subscribeToTradingUpdates: wsService.subscribeToTradingUpdates.bind(wsService),\n    subscribeToAIPredictions: wsService.subscribeToAIPredictions.bind(wsService),\n  };\n};