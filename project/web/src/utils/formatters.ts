// Formatting utilities for the AI Trading Platform\n\n/**\n * Format currency values\n */\nexport const formatCurrency = (\n  value: number,\n  currency: string = 'USD',\n  locale: string = 'en-US'\n): string => {\n  return new Intl.NumberFormat(locale, {\n    style: 'currency',\n    currency,\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2,\n  }).format(value);\n};\n\n/**\n * Format percentage values\n */\nexport const formatPercentage = (\n  value: number,\n  decimals: number = 2,\n  locale: string = 'en-US'\n): string => {\n  return new Intl.NumberFormat(locale, {\n    style: 'percent',\n    minimumFractionDigits: decimals,\n    maximumFractionDigits: decimals,\n  }).format(value / 100);\n};\n\n/**\n * Format numbers with appropriate precision\n */\nexport const formatNumber = (\n  value: number,\n  decimals: number = 2,\n  locale: string = 'en-US'\n): string => {\n  return new Intl.NumberFormat(locale, {\n    minimumFractionDigits: decimals,\n    maximumFractionDigits: decimals,\n  }).format(value);\n};\n\n/**\n * Format large numbers with abbreviations (K, M, B)\n */\nexport const formatCompactNumber = (\n  value: number,\n  locale: string = 'en-US'\n): string => {\n  return new Intl.NumberFormat(locale, {\n    notation: 'compact',\n    compactDisplay: 'short',\n  }).format(value);\n};\n\n/**\n * Format forex prices with proper precision\n */\nexport const formatForexPrice = (value: number, symbol: string): string => {\n  // JPY pairs typically have 3 decimal places, others have 5\n  const decimals = symbol.includes('JPY') ? 3 : 5;\n  return formatNumber(value, decimals);\n};\n\n/**\n * Format trading volume\n */\nexport const formatVolume = (value: number): string => {\n  if (value >= 1000000) {\n    return `${(value / 1000000).toFixed(1)}M`;\n  } else if (value >= 1000) {\n    return `${(value / 1000).toFixed(1)}K`;\n  }\n  return formatNumber(value, 2);\n};\n\n/**\n * Format time durations\n */\nexport const formatDuration = (seconds: number): string => {\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  const secs = seconds % 60;\n\n  if (hours > 0) {\n    return `${hours}h ${minutes}m ${secs}s`;\n  } else if (minutes > 0) {\n    return `${minutes}m ${secs}s`;\n  }\n  return `${secs}s`;\n};\n\n/**\n * Format date and time\n */\nexport const formatDateTime = (\n  date: Date | string,\n  options: Intl.DateTimeFormatOptions = {}\n): string => {\n  const defaultOptions: Intl.DateTimeFormatOptions = {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    ...options,\n  };\n\n  return new Date(date).toLocaleDateString('en-US', defaultOptions);\n};\n\n/**\n * Format date only\n */\nexport const formatDate = (\n  date: Date | string,\n  options: Intl.DateTimeFormatOptions = {}\n): string => {\n  const defaultOptions: Intl.DateTimeFormatOptions = {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n    ...options,\n  };\n\n  return new Date(date).toLocaleDateString('en-US', defaultOptions);\n};\n\n/**\n * Format time only\n */\nexport const formatTime = (\n  date: Date | string,\n  options: Intl.DateTimeFormatOptions = {}\n): string => {\n  const defaultOptions: Intl.DateTimeFormatOptions = {\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    ...options,\n  };\n\n  return new Date(date).toLocaleTimeString('en-US', defaultOptions);\n};\n\n/**\n * Format relative time (e.g., \"2 hours ago\")\n */\nexport const formatRelativeTime = (date: Date | string): string => {\n  const now = new Date();\n  const targetDate = new Date(date);\n  const diffInSeconds = Math.floor((now.getTime() - targetDate.getTime()) / 1000);\n\n  const rtf = new Intl.RelativeTimeFormat('en', { numeric: 'auto' });\n\n  if (diffInSeconds < 60) {\n    return rtf.format(-diffInSeconds, 'second');\n  }\n\n  const diffInMinutes = Math.floor(diffInSeconds / 60);\n  if (diffInMinutes < 60) {\n    return rtf.format(-diffInMinutes, 'minute');\n  }\n\n  const diffInHours = Math.floor(diffInMinutes / 60);\n  if (diffInHours < 24) {\n    return rtf.format(-diffInHours, 'hour');\n  }\n\n  const diffInDays = Math.floor(diffInHours / 24);\n  if (diffInDays < 30) {\n    return rtf.format(-diffInDays, 'day');\n  }\n\n  const diffInMonths = Math.floor(diffInDays / 30);\n  if (diffInMonths < 12) {\n    return rtf.format(-diffInMonths, 'month');\n  }\n\n  const diffInYears = Math.floor(diffInMonths / 12);\n  return rtf.format(-diffInYears, 'year');\n};\n\n/**\n * Format file sizes\n */\nexport const formatFileSize = (bytes: number): string => {\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n  if (bytes === 0) return '0 Bytes';\n  \n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\n  return `${(bytes / Math.pow(1024, i)).toFixed(2)} ${sizes[i]}`;\n};\n\n/**\n * Format trading position status\n */\nexport const formatPositionStatus = (type: 'buy' | 'sell'): string => {\n  return type.toUpperCase();\n};\n\n/**\n * Format confidence score\n */\nexport const formatConfidence = (confidence: number): string => {\n  return `${Math.round(confidence * 100)}%`;\n};\n\n/**\n * Format P&L with color coding\n */\nexport const formatPnL = (value: number, includePlus: boolean = true): {\n  formatted: string;\n  color: 'success' | 'error' | 'neutral';\n} => {\n  const formatted = `${value >= 0 && includePlus ? '+' : ''}${formatCurrency(value)}`;\n  const color = value > 0 ? 'success' : value < 0 ? 'error' : 'neutral';\n  \n  return { formatted, color };\n};\n\n/**\n * Format change with percentage\n */\nexport const formatChange = (current: number, previous: number): {\n  absolute: string;\n  percentage: string;\n  isPositive: boolean;\n} => {\n  const change = current - previous;\n  const percentageChange = previous !== 0 ? (change / previous) * 100 : 0;\n  \n  return {\n    absolute: `${change >= 0 ? '+' : ''}${formatCurrency(change)}`,\n    percentage: `${percentageChange >= 0 ? '+' : ''}${formatPercentage(percentageChange)}`,\n    isPositive: change >= 0,\n  };\n};\n\n/**\n * Format trading symbol\n */\nexport const formatSymbol = (symbol: string): string => {\n  // Format pairs like EURUSD to EUR/USD\n  if (symbol.length === 6) {\n    return `${symbol.slice(0, 3)}/${symbol.slice(3)}`;\n  }\n  return symbol;\n};\n\n/**\n * Format latency\n */\nexport const formatLatency = (milliseconds: number): string => {\n  if (milliseconds < 1) {\n    return `${(milliseconds * 1000).toFixed(0)}Î¼s`;\n  } else if (milliseconds < 1000) {\n    return `${milliseconds.toFixed(1)}ms`;\n  } else {\n    return `${(milliseconds / 1000).toFixed(2)}s`;\n  }\n};\n\n/**\n * Format risk level\n */\nexport const formatRiskLevel = (level: number): {\n  label: string;\n  color: 'success' | 'warning' | 'error';\n} => {\n  if (level <= 3) {\n    return { label: 'Low', color: 'success' };\n  } else if (level <= 7) {\n    return { label: 'Medium', color: 'warning' };\n  } else {\n    return { label: 'High', color: 'error' };\n  }\n};\n\n/**\n * Truncate text with ellipsis\n */\nexport const truncateText = (text: string, maxLength: number): string => {\n  if (text.length <= maxLength) return text;\n  return `${text.slice(0, maxLength)}...`;\n};\n\n/**\n * Format API response time\n */\nexport const formatResponseTime = (milliseconds: number): string => {\n  if (milliseconds < 100) {\n    return `${milliseconds}ms`;\n  } else if (milliseconds < 1000) {\n    return `${milliseconds}ms`;\n  } else {\n    return `${(milliseconds / 1000).toFixed(1)}s`;\n  }\n};"