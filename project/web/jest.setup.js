import '@testing-library/jest-dom';\n\n// Mock WebSocket\nglobal.WebSocket = class WebSocket {\n  constructor(url) {\n    this.url = url;\n    this.readyState = WebSocket.CONNECTING;\n    setTimeout(() => {\n      this.readyState = WebSocket.OPEN;\n      if (this.onopen) this.onopen();\n    }, 100);\n  }\n\n  send(data) {\n    // Mock send\n  }\n\n  close() {\n    this.readyState = WebSocket.CLOSED;\n    if (this.onclose) this.onclose();\n  }\n\n  addEventListener(type, listener) {\n    this[`on${type}`] = listener;\n  }\n\n  removeEventListener(type, listener) {\n    this[`on${type}`] = null;\n  }\n};\n\nWebSocket.CONNECTING = 0;\nWebSocket.OPEN = 1;\nWebSocket.CLOSING = 2;\nWebSocket.CLOSED = 3;\n\n// Mock socket.io-client\njest.mock('socket.io-client', () => {\n  return {\n    io: jest.fn(() => ({\n      on: jest.fn(),\n      off: jest.fn(),\n      emit: jest.fn(),\n      connect: jest.fn(),\n      disconnect: jest.fn(),\n      connected: true,\n    })),\n  };\n});\n\n// Mock next/router\njest.mock('next/router', () => ({\n  useRouter: () => ({\n    route: '/',\n    pathname: '/',\n    query: {},\n    asPath: '/',\n    push: jest.fn(),\n    replace: jest.fn(),\n    reload: jest.fn(),\n    back: jest.fn(),\n    prefetch: jest.fn(),\n    beforePopState: jest.fn(),\n    events: {\n      on: jest.fn(),\n      off: jest.fn(),\n      emit: jest.fn(),\n    },\n  }),\n}));\n\n// Mock IntersectionObserver\nglobal.IntersectionObserver = class IntersectionObserver {\n  constructor() {}\n  observe() {\n    return null;\n  }\n  disconnect() {\n    return null;\n  }\n  unobserve() {\n    return null;\n  }\n};\n\n// Mock ResizeObserver\nglobal.ResizeObserver = class ResizeObserver {\n  constructor() {}\n  observe() {\n    return null;\n  }\n  disconnect() {\n    return null;\n  }\n  unobserve() {\n    return null;\n  }\n};\n\n// Mock matchMedia\nObject.defineProperty(window, 'matchMedia', {\n  writable: true,\n  value: jest.fn().mockImplementation(query => ({\n    matches: false,\n    media: query,\n    onchange: null,\n    addListener: jest.fn(), // deprecated\n    removeListener: jest.fn(), // deprecated\n    addEventListener: jest.fn(),\n    removeEventListener: jest.fn(),\n    dispatchEvent: jest.fn(),\n  })),\n});\n\n// Mock HTMLCanvasElement.getContext\nHTMLCanvasElement.prototype.getContext = jest.fn(() => ({\n  fillRect: jest.fn(),\n  clearRect: jest.fn(),\n  getImageData: jest.fn(() => ({ data: new Array(4) })),\n  putImageData: jest.fn(),\n  createImageData: jest.fn(() => []),\n  setTransform: jest.fn(),\n  drawImage: jest.fn(),\n  save: jest.fn(),\n  fillText: jest.fn(),\n  restore: jest.fn(),\n  beginPath: jest.fn(),\n  moveTo: jest.fn(),\n  lineTo: jest.fn(),\n  closePath: jest.fn(),\n  stroke: jest.fn(),\n  translate: jest.fn(),\n  scale: jest.fn(),\n  rotate: jest.fn(),\n  arc: jest.fn(),\n  fill: jest.fn(),\n  measureText: jest.fn(() => ({ width: 0 })),\n  transform: jest.fn(),\n  rect: jest.fn(),\n  clip: jest.fn(),\n}));\n\n// Silence console errors during tests\nconst originalError = console.error;\nbeforeAll(() => {\n  console.error = (...args) => {\n    if (\n      typeof args[0] === 'string' &&\n      args[0].includes('Warning: ReactDOM.render is deprecated')\n    ) {\n      return;\n    }\n    originalError.call(console, ...args);\n  };\n});\n\nafterAll(() => {\n  console.error = originalError;\n});"