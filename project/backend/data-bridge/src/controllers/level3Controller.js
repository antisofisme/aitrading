/**
 * Level 3 Data Bridge Controller
 * Handles Level 3 specific API endpoints and orchestration
 */

const logger = require('../utils/logger');
const Level3DataBridge = require('../services/Level3DataBridge');

class Level3Controller {
  constructor(dataBridgeServer) {
    this.server = dataBridgeServer;
    this.mt5Enhanced = dataBridgeServer.mt5Enhanced;
    this.dataValidation = dataBridgeServer.dataValidation;
    this.realTimeStreaming = dataBridgeServer.realTimeStreaming;
    this.performanceMonitoring = dataBridgeServer.performanceMonitoring;
  }

  /**
   * Get comprehensive Level 3 status
   */
  async getLevel3Status(req, res) {
    try {
      const performanceReport = this.performanceMonitoring.getPerformanceReport();
      const validationMetrics = this.dataValidation.getValidationMetrics();
      const streamingMetrics = this.realTimeStreaming.getMetrics();
      const mt5Metrics = this.mt5Enhanced.getPerformanceMetrics();

      const level3Status = {
        overall: {
          status: this.calculateOverallStatus(performanceReport, validationMetrics, mt5Metrics),
          level3Complete: true,
          timestamp: new Date().toISOString()
        },
        performance: {
          current: performanceReport.current,
          targets: {
            ticksPerSecond: {
              current: mt5Metrics.ticksPerSecond,
              target: 50,
              met: mt5Metrics.ticksPerSecond >= 50
            },
            latency: {
              current: performanceReport.current.performance.averageLatency,
              target: 10,
              met: performanceReport.current.performance.averageLatency <= 10,
              unit: 'ms'
            },
            accuracy: {
              current: validationMetrics.validationRate,\n              target: 99.9,\n              met: validationMetrics.validationRate >= 99.9,\n              unit: '%'\n            }\n          },\n          summary: performanceReport.summary\n        },\n        dataFlow: {\n          validation: {\n            enabled: true,\n            metrics: validationMetrics,\n            realTimeEnabled: this.dataValidation.config.enableRealTimeValidation\n          },\n          streaming: {\n            enabled: true,\n            connections: streamingMetrics.connections,\n            performance: streamingMetrics.performance\n          },\n          multiSource: {\n            enabled: this.mt5Enhanced.config.multiSourceEnabled,\n            sources: this.getDataSourcesStatus(),\n            aggregation: 'weighted_average'\n          }\n        },\n        reliability: {\n          failover: {\n            enabled: this.mt5Enhanced.config.failoverEnabled,\n            status: this.mt5Enhanced.failoverStatus\n          },\n          uptime: performanceReport.current.performance.uptime,\n          dataIntegrity: validationMetrics.validationRate\n        },\n        features: {\n          eventDrivenArchitecture: this.mt5Enhanced.config.eventDrivenMode,\n          realTimeValidation: this.dataValidation.config.enableRealTimeValidation,\n          anomalyDetection: this.dataValidation.config.enableAnomalyDetection,\n          performanceMonitoring: true,\n          multiTenantSupport: true\n        }\n      };\n\n      res.json({\n        success: true,\n        level: 3,\n        data: level3Status\n      });\n\n    } catch (error) {\n      logger.error('Error getting Level 3 status:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Failed to get Level 3 status',\n        message: error.message\n      });\n    }\n  }\n\n  /**\n   * Run Level 3 performance tests\n   */\n  async runPerformanceTest(req, res) {\n    try {\n      const { duration = 60, targetTPS = 50 } = req.body;\n\n      logger.info(`Starting Level 3 performance test: ${duration}s at ${targetTPS} TPS`);\n\n      const testResults = {\n        testId: `test_${Date.now()}`,\n        startTime: new Date().toISOString(),\n        duration,\n        targetTPS,\n        results: {\n          actualTPS: 0,\n          averageLatency: 0,\n          maxLatency: 0,\n          dataAccuracy: 0,\n          totalTicks: 0,\n          validTicks: 0,\n          invalidTicks: 0\n        },\n        status: 'running'\n      };\n\n      // Start performance test\n      const testStartTime = Date.now();\n      let tickCount = 0;\n      let latencySum = 0;\n      let maxLatency = 0;\n\n      const testInterval = setInterval(async () => {\n        const batchStartTime = process.hrtime.bigint();\n\n        // Generate test ticks\n        const ticksInBatch = Math.ceil(targetTPS / 10); // 10 batches per second\n\n        for (let i = 0; i < ticksInBatch; i++) {\n          const testTick = this.generateTestTick();\n          const tickStartTime = process.hrtime.bigint();\n\n          // Process through Level 3 pipeline\n          const validationResult = await this.dataValidation.validateData(testTick, 'tick');\n\n          const tickEndTime = process.hrtime.bigint();\n          const tickLatency = Number(tickEndTime - tickStartTime) / 1000000;\n\n          tickCount++;\n          latencySum += tickLatency;\n          maxLatency = Math.max(maxLatency, tickLatency);\n\n          if (validationResult.isValid) {\n            testResults.results.validTicks++;\n          } else {\n            testResults.results.invalidTicks++;\n          }\n        }\n\n        testResults.results.totalTicks = tickCount;\n\n      }, 100); // Every 100ms\n\n      // Complete test after duration\n      setTimeout(() => {\n        clearInterval(testInterval);\n\n        const testEndTime = Date.now();\n        const actualDuration = (testEndTime - testStartTime) / 1000;\n\n        testResults.results.actualTPS = tickCount / actualDuration;\n        testResults.results.averageLatency = latencySum / tickCount;\n        testResults.results.maxLatency = maxLatency;\n        testResults.results.dataAccuracy = (testResults.results.validTicks / tickCount) * 100;\n        testResults.endTime = new Date().toISOString();\n        testResults.status = 'completed';\n\n        // Determine if test passed Level 3 requirements\n        testResults.passed = {\n          throughput: testResults.results.actualTPS >= targetTPS,\n          latency: testResults.results.averageLatency <= 10,\n          accuracy: testResults.results.dataAccuracy >= 99.9,\n          overall: false\n        };\n\n        testResults.passed.overall = Object.values(testResults.passed)\n          .slice(0, 3) // Exclude 'overall'\n          .every(result => result);\n\n        logger.info('Level 3 performance test completed:', testResults);\n\n      }, duration * 1000);\n\n      res.json({\n        success: true,\n        message: 'Performance test started',\n        testId: testResults.testId,\n        estimatedCompletion: new Date(Date.now() + (duration * 1000)).toISOString()\n      });\n\n    } catch (error) {\n      logger.error('Error running performance test:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Failed to run performance test',\n        message: error.message\n      });\n    }\n  }\n\n  /**\n   * Get data source health and performance\n   */\n  async getDataSourceHealth(req, res) {\n    try {\n      const sources = [];\n\n      // Get MT5 Enhanced sources\n      if (this.mt5Enhanced.dataSources) {\n        this.mt5Enhanced.dataSources.forEach((source, sourceId) => {\n          sources.push({\n            id: sourceId,\n            type: source.type,\n            status: source.active ? 'active' : 'inactive',\n            priority: source.priority,\n            reliability: source.reliability,\n            latency: source.latency,\n            lastUpdate: new Date().toISOString()\n          });\n        });\n      }\n\n      const healthReport = {\n        totalSources: sources.length,\n        activeSources: sources.filter(s => s.status === 'active').length,\n        averageReliability: sources.length > 0 ?\n          sources.reduce((sum, s) => sum + s.reliability, 0) / sources.length : 0,\n        sources,\n        multiSourceEnabled: this.mt5Enhanced.config.multiSourceEnabled,\n        failoverEnabled: this.mt5Enhanced.config.failoverEnabled,\n        timestamp: new Date().toISOString()\n      };\n\n      res.json({\n        success: true,\n        data: healthReport\n      });\n\n    } catch (error) {\n      logger.error('Error getting data source health:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Failed to get data source health',\n        message: error.message\n      });\n    }\n  }\n\n  /**\n   * Configure Level 3 settings\n   */\n  async configureLevel3Settings(req, res) {\n    try {\n      const {\n        targetTicksPerSecond,\n        enableMultiSource,\n        enableFailover,\n        enableEventDriven,\n        validationThresholds,\n        performanceTargets\n      } = req.body;\n\n      const updates = [];\n\n      // Update MT5 Enhanced configuration\n      if (targetTicksPerSecond !== undefined) {\n        this.mt5Enhanced.config.targetTicksPerSecond = targetTicksPerSecond;\n        updates.push(`Target TPS updated to ${targetTicksPerSecond}`);\n      }\n\n      if (enableMultiSource !== undefined) {\n        this.mt5Enhanced.config.multiSourceEnabled = enableMultiSource;\n        updates.push(`Multi-source aggregation ${enableMultiSource ? 'enabled' : 'disabled'}`);\n      }\n\n      if (enableFailover !== undefined) {\n        this.mt5Enhanced.config.failoverEnabled = enableFailover;\n        updates.push(`Failover ${enableFailover ? 'enabled' : 'disabled'}`);\n      }\n\n      if (enableEventDriven !== undefined) {\n        this.mt5Enhanced.config.eventDrivenMode = enableEventDriven;\n        updates.push(`Event-driven mode ${enableEventDriven ? 'enabled' : 'disabled'}`);\n      }\n\n      // Update validation thresholds\n      if (validationThresholds) {\n        Object.assign(this.dataValidation.config, validationThresholds);\n        updates.push('Validation thresholds updated');\n      }\n\n      // Update performance targets\n      if (performanceTargets) {\n        Object.assign(this.performanceMonitoring.config.alertThresholds, performanceTargets);\n        updates.push('Performance targets updated');\n      }\n\n      res.json({\n        success: true,\n        message: 'Level 3 configuration updated',\n        updates,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info('Level 3 configuration updated:', updates);\n\n    } catch (error) {\n      logger.error('Error configuring Level 3 settings:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Failed to configure Level 3 settings',\n        message: error.message\n      });\n    }\n  }\n\n  /**\n   * Get Level 3 metrics dashboard data\n   */\n  async getMetricsDashboard(req, res) {\n    try {\n      const performanceReport = this.performanceMonitoring.getPerformanceReport();\n      const validationMetrics = this.dataValidation.getValidationMetrics();\n      const streamingMetrics = this.realTimeStreaming.getMetrics();\n\n      const dashboard = {\n        summary: {\n          level3Status: performanceReport.summary.status,\n          targetsMetPercentage: performanceReport.summary.targetsMetPercentage,\n          alertsCount: performanceReport.summary.alertsCount\n        },\n        realTimeMetrics: {\n          ticksPerSecond: performanceReport.current.performance.ticksPerSecond,\n          averageLatency: performanceReport.current.performance.averageLatency,\n          dataAccuracy: validationMetrics.validationRate,\n          activeConnections: streamingMetrics.connections.active\n        },\n        performance: {\n          targets: {\n            throughputTarget: 50,\n            latencyTarget: 10,\n            accuracyTarget: 99.9\n          },\n          current: {\n            throughput: performanceReport.current.performance.ticksPerSecond,\n            latency: performanceReport.current.performance.averageLatency,\n            accuracy: validationMetrics.validationRate\n          }\n        },\n        trends: performanceReport.trends,\n        alerts: performanceReport.recentAlerts,\n        recommendations: performanceReport.recommendations,\n        timestamp: new Date().toISOString()\n      };\n\n      res.json({\n        success: true,\n        data: dashboard\n      });\n\n    } catch (error) {\n      logger.error('Error getting metrics dashboard:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Failed to get metrics dashboard',\n        message: error.message\n      });\n    }\n  }\n\n  // Helper methods\n  calculateOverallStatus(performanceReport, validationMetrics, mt5Metrics) {\n    const targets = {\n      throughput: mt5Metrics.ticksPerSecond >= 50,\n      latency: performanceReport.current.performance.averageLatency <= 10,\n      accuracy: validationMetrics.validationRate >= 99.9,\n      uptime: mt5Metrics.isConnected\n    };\n\n    const metCount = Object.values(targets).filter(Boolean).length;\n\n    if (metCount === 4) return 'excellent';\n    if (metCount === 3) return 'good';\n    if (metCount >= 2) return 'warning';\n    return 'critical';\n  }\n\n  getDataSourcesStatus() {\n    if (!this.mt5Enhanced.dataSources) return [];\n\n    return Array.from(this.mt5Enhanced.dataSources.entries()).map(([id, source]) => ({\n      id,\n      type: source.type,\n      active: source.active,\n      priority: source.priority,\n      reliability: source.reliability,\n      latency: source.latency\n    }));\n  }\n\n  generateTestTick() {\n    const symbols = ['EURUSD', 'GBPUSD', 'USDJPY', 'AUDUSD'];\n    const symbol = symbols[Math.floor(Math.random() * symbols.length)];\n    const basePrice = this.getBasePrice(symbol);\n    const variation = (Math.random() - 0.5) * 0.001;\n\n    return {\n      symbol,\n      bid: Number((basePrice + variation).toFixed(5)),\n      ask: Number((basePrice + variation + 0.0002).toFixed(5)),\n      volume: Math.floor(Math.random() * 100) + 1,\n      timestamp: new Date().toISOString(),\n      source: 'performance_test'\n    };\n  }\n\n  getBasePrice(symbol) {\n    const basePrices = {\n      'EURUSD': 1.0850,\n      'GBPUSD': 1.2650,\n      'USDJPY': 149.50,\n      'AUDUSD': 0.6750\n    };\n    return basePrices[symbol] || 1.0000;\n  }\n}\n\nmodule.exports = Level3Controller;